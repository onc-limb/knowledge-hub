### 序論

本稿は、ソフトウェア設計における単一責任の原則（SRP: Single Responsibility Principle）について、その定義、目的、および実践方法を解説するものである。『Clean Architecture』で提唱されている「アクター」の概念を中心に、原則の本質を技術的観点から詳述する。

### 1. 単一責任の原則の定義

単一責任の原則には、古典的な定義と、それをより具体化した現代的な定義が存在する。

### 1.1. 古典的な定義

SRPは当初、次のように定義された。

> モジュールを変更する理由はたった一つだけであるべきである。

この定義における「理由」の曖昧さが、多様な解釈を生む一因となった。

### 1.2. アクターに基づく再定義

この曖昧さを解消するため、『Clean Architecture』の著者であるRobert C. Martinは、SRPを次のように再定義した。

> モジュールはたったひとつのアクターに対して責務を負うべきである。

ここでの**アクター**とは、そのモジュールに変更を要求する利害関係者（ステークホルダー）の一人、またはそのグループを指す。

### 2. SRP違反の具体例と問題点

アクターの概念に基づき、SRP違反の例を考察する。

**事例:** あるシステムに、従業員情報を扱う `Employee` クラスが存在し、以下のメソッドを持つとする。

- `calculatePay()`: 給与を計算するメソッド
- `reportHours()`: 勤怠時間を報告書形式で出力するメソッド

**分析:** 各メソッドに変更を要求するアクターを特定する。

- `calculatePay()` の仕様変更を要求するのは**経理部門**である。
- `reportHours()` の仕様変更を要求するのは**人事部門**である。

この `Employee` クラスは、「経理部門」と「人事部門」という2つの異なるアクターに対する責任を同時に負っている。これはSRPに違反した状態である。

**問題点:** 単一のクラスが複数のアクターに責任を負うと、以下の問題が発生する可能性がある。

- **意図しない副作用**: 一方のアクター（例：経理部門）の要求に応えるためのコード修正が、他方のアクター（例：人事部門）が利用する機能に予期せぬ影響を与え、不具合を発生させるリスクが高まる。
- **マージコンフリクト**: 異なるアクターからの要求が同時期に発生した場合、複数の開発者が同じソースファイルを変更することになり、マージコンフリクトの原因となる。

### 3. SRPに関する一般的な誤解

SRPは「1つのクラスが持つべきメソッドは1つだけ」という意味ではない。原則の判断基準はメソッドの数ではなく、**それらのメソッド群が応えるべきアクターが単一であるか否か**である。

例えば、`PayCalculator` クラスが給与計算という単一の責任を果たすために、基本給計算、手当計算、税金計算といった複数のメソッドを持つことはSRPに違反しない。これらのメソッドはすべて「経理部門」という単一のアクターの関心事に応えるものであり、凝集性の高い設計と見なされる。

### 4. SRPの目的と実践方法

### 4.1. 目的

SRPを遵守する目的は、ソフトウェアの保守性を高めることにある。具体的には以下の効果が期待できる。

- **変更耐性の向上**: 仕様変更の影響範囲が限定され、修正が他機能へ及ぼすリスクが低減する。
- **可読性の向上**: モジュールの責務が明確になり、コードの理解が容易になる。
- **コンポーネントの再利用性向上**: 特定の責任に特化したモジュールは、他のコンテキストでも再利用しやすくなる。

### 4.2. 実践方法

SRPを実践するには、アクターや関心事に基づいてモジュールを分割する。

- **責任分離**: 上記事例の場合、`Employee` クラスを `PayCalculator` クラスと `HourReporter` クラスに分割する。データのみを保持する `EmployeeData` クラスを用意し、各ロジッククラスがそれを参照する構成も有効である。
- **Facadeパターンの適用**: 責任分離によってクラス数が増加し、クライアント側のコードが複雑化する場合、関連するクラス群をまとめる窓口としてFacadeパターンを適用することが有効な手段となる。

### 結論

単一責任の原則とは、モジュールが責任を負うべきアクターを一つに限定することで、変更による影響範囲を局所化し、ソフトウェア全体の保守性と堅牢性を向上させるための設計原則である。設計時には「このコードの変更を要求するのは誰か」という観点を持つことが、この原則を遵守する上で極めて重要となる。

[1] Clean Architecture 第7章

[2] 良いコード悪いコードで学ぶ設計入門 第8章